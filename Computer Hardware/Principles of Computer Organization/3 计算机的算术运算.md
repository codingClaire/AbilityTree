# 3 计算机的算术运算

## 3.2 加法和减法
溢出 加法：当源操作数符号相同时不会溢出

add addi sub 溢出时发生异常
addu addiu subu 溢出时不会发生异常

算术逻辑单元：执行加减 逻辑与、或等运算的硬件  
异常：也叫中断，一种打断正常执行过程的事件，用于溢出检测  
中断：来自处理器外部的异常  
算术逻辑单元（P453)

***

## 3.3 乘法
位数

|第一个源操作数|第二个源操作数|结果|
|:---:|:---:|:---:|
|乘数 |被乘数| 积|
|n|m|n+m|

每一步乘法
* 乘数位=1 被乘数复制到合适的位置
* 乘数位=0 0放到合适的位置

### 3.3.1 顺序的乘法算法和硬件

计算0010*0011的积

|迭代次数|步骤|乘数|被乘数|乘积|
|:----:|:----:|:----:|:----:|:----:|
|0|初始值|0011|0000 0010|0000 0000|
|1|（乘数末尾是1）乘积=乘积+被乘数|0011|0000 0010|0000 0010|
|1|左移被乘数|0011|0000 0100|0000 0010|
|1|右移乘数|0001|0000 0100|0000 0010|
|2|（乘数末尾是1）乘积=乘积+被乘数|0001|0000 0100|0000 0110|
|2|左移被乘数|0001|0000 1000|0000 0110|
|2|右移乘数|0000|0000 1000|0000 0110|
|3|（乘数末尾是0）无操作|0000|0000 1000|0000 0110|
|3|左移被乘数|0000|0001 0000|0000 0110|
|3|右移乘数|0000|0001 000|0000 0110|
|4|（乘数末尾是0）无操作|0000|0001 000|0000 0110|
|4|左移被乘数|0000|0010 0000|0000 0110|
|4|左移被乘数|0000|0010 0000|0000 0110|

### 3.3.2 有符号乘法
将被乘数和乘数转化位整数 并记住原来的符号位

迭代31次 符号位不必参与运算

### 3.3.3 更快速的乘法

乘法运算开始时 检查乘数的32位 判定被乘数是否被加上  
**主要思想** 为乘数的每一位提供一个32位的加法器  
一个用来输入被乘数和一乘数位相与的结果  另一个是上一个加法器的输出

将每个右边的加法器作为左边加法器的输入 形成一个高32位的加法器栈  
这样只需要等待lg(32) 即5次32位长加法的时间  无需等待32次

展开循环 实现最小的时延  
进位保留加法器
### 3.3.4 MIPS中的加法
一对32位寄存器容纳64位积 (Hi Lo)
两条指令
* 乘法(mult)
* 无符号乘法(multu)

mflo指令  取得32位的整数积  
mfhi指令
这两个指令将积送入指定的寄存器

***
## 3.4 除法

除数为0
### 3.4.1 除法运算及其硬件结构
 计算0000 0111 除以0010

|迭代次数|步骤|商|除数|余数|
 |:-----:|:----:|:----:|:-----:|:----:|
 |0|初始值|0000|0010 0000(除数放在高位)|0000 0111|
 |1|余数=余数-除数|0000|0010 0000|1110 0111|
 |1|余数最高位为1 说明为负 恢复余数 商左移，最低为上0|0000|0010 0000|0000 0111|
 |1|除数右移|0000|0001 0000|0000 0111|
 |2|余数=余数-除数|0000|0001 0000|1111 0111|
|2|余数最高位为1 说明为负 恢复余数 商左移，最低为上0|0000|0001 0000|0000 0111|
|2|除数右移|0000|0000 1000|0000 0111|
|3|余数=余数-除数|0000|0000 1000|1111 1111|
|3|余数最高位为1 说明为负 恢复余数 商左移，最低为上0|0000|0000 1000|0000 0111|
|3|除数右移|0000|0000 0100|0000 0111|
|4|余数=余数-除数|0000|0000 0100|0000 0011|
|4|余数最高位为0 商左移，最低位上为1|0001|0000 0100|0000 0011|
|4|除数右移|0001|0000 0010|0000 0011|
|5|余数=余数-除数|0001|0000 0010|0000 0001|
|5|余数最高位为0 商左移，最低位上为1|0011|0000 0010|0000 0001|
|5|除数右移|0011|0000 0001|0000 0001|

**算法需要n+1步获得适当的商和余数**

#### 改进版除法器
余数寄存器为64位  
余数和商一起左移  
将商寄存器和余数寄存器的右半部分进行了拼接
(PPT)

### 3.4.2 有符号除法

### 3.4.3 更快速的除法

### 3.4.4 MIPS中的除法
div divu
MIPS汇编器允许指令使用三个寄存器   
而且采用mflo mfhi 指令将运算结果放入指定的通用寄存器

### 3.4.5 小结
(P194) MIPS汇编语言指令表
***
## 3.5 浮点运算

**科学记数法** 十进制小数点左边只有一位整数的计数法  
**规格化数** 没有前导零的浮点计数法  

用科学计数法表示二进制数  
小数点称为“二进制小数点”

**浮点数** 二进制小数点不固定的表达数的记数法  

### 3.5.1 浮点表示
**尾数** 值在0-1之间
**指数**  表示小数点的位置

MIPS中浮点数表示 ：**符号和数值**

s为浮点数的符号（1负 0正）

单精度

|31|30--23|22--0|
|:--:|:--:|:--:|
|s（符号位）|指数exponent|尾数Fraction|

浮点数`(-1)^S*F*2^E`  

**溢出**  
上溢：正指数太大而不能在指数域中表示出来  
下溢：负指数太大而不能在指数域中表示出来

减少上溢和下溢的方法：  
**采用更大指数的格式**  
双精度double   
单精度（上述）

双精度浮点数

|31|30--20（11位）|19--0 以及另一个字的32位（共52位）|
|:--:|:--:|:--:|
|s（符号位）|指数exponent|尾数Fraction|  

#### IEEE754浮点标准
将更多的数据为打包到有效位数部分  
IEEE754浮点标准隐藏了规格化二进制数的前导位1  
在单精度下 数有24位宽
双精度下 数有53位宽  
0没有前导位1 指数保留为0 硬件不会将前导位1加到尾数上

浮点数`(-1)^S*(F+1)*2^E`

**带偏阶的记数法**

浮点数`(-1)^S*(F+1)*2^(E-bias)`

单精度的偏阶为127  
双精度的偏阶为1023

当真正的指数为-1时 要加127 表示为126  
