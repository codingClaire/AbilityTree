# 4 处理器
## 4.1 引言

决定计算机的性能的三个因素
* 指令数目
* 时钟周期
* 每条指令所需的时钟周期数(CPI)


编译器、指令集-->决定了一个程序所需的指令数目  
处理器的实现方式-->决定了时钟周期和CPI  

### 一个基本的MIPS实现

MIPS指令的一个核心指令集
* 存储访问指令：lw sw
* 算术逻辑指令：add sub AND OR slt
* 分支指令： beq j

没有包含所有的整数指令 也没有包含浮点数指令  


#### 实现方式概述
* 实现每条指令的前两步
  + PC指向**指令所在的存储单元** 取出指令
  + 通过指令字段内容 选择读取一个/两个寄存器（取字只读取一个，其他大多数都是读取两个）


MIPS实现的抽象视图  
某个单元的数据可能来自于两个不同的单元  
不能简单直接将这些数据线连接在一起   
增加一个数据单元-->数据选择器 多选器  
存取指令和算术逻辑指令写入寄存器堆  
操作由控制信号决定  控制信号是由指令的某些字段决定的  

图4.2
三个多选器：
* 最上面 ALU的零输出和一个指令是否为分支指令的信号相与
* 中间 输出到寄存器堆的选择器 用来选择被写入寄存器队中的时ALU的输出 还是数据存储器的输出
* 最下面 决定ALU的第二个输入是来自寄存器堆 还是指令的偏移量字段
***
### 4.2 逻辑设计的一般方法

**组合单元** 输出只取决于当前的输入  一个操作单元  
输入相同时 输出也相同   
ALU 与门  
**状态单元** 包含状态的单元   
一个单元带有内部存储功能  就包含状态  
指令存储器 数据存储器 寄存器  

状态单元的两个输入和一个输出
* 输入写入单元的数据值
* 输入决定何时写入的时钟信号  
* 输出提供在前一个时钟信号写入单元的数据值

#### 时钟方法
时钟方法 规定了信号可以读出和写入的时间 避免不确定性  
**采用边沿触发的时钟方法**
所有状态改变发生在时钟沿的时钟机制  

写控制信号  
当时钟边沿到来 并且写控制信号有效时 状态单元才改变状态  

有效：信号为逻辑高
无效：信号为逻辑低

状态单元在同一个时间读写  不会因为竞争而出现中间数据  
在一个时钟周期内读出一个寄存器的值 并经过组合逻辑 将新值写入该寄存器  

MIPS中几乎所有状态单元 逻辑单元的输入、输出都为32位  
总线：宽度为1位以上的信号  

***
## 4.3 建立数据通路  
#### 数据通路部件
一个用来操作或保存处理器中数据的单元  
 包括指令存储器 数据存储器 寄存器堆 ALU和加法器
##### 程序计数器(PC)
保存当前指令的地址  

**存取指令**
* 指令存储器(只提供读访问 只读的 视为组合逻辑)
* 程序计数器(每个周期末都会被写入 不需要写信号)
* 加法器(只进行加法的ALU)

**R型指令**  
读两个寄存器  
对内容进行ALU操作  
再写回结果  

* **寄存器堆**
寄存器堆：包含一系列寄存器的状态单元 可以通过寄存器号进行读写  
  + 为读出一个数据字
    - 输入一个要读的寄存器号
    - 一个从寄存器堆中读出来的结果的输出指示  
  + 为写入一个数据字
    - 输入一个提供要写的寄存器号
    - 输入要写的数据  

* **ALU**
写操作由写控制信号控制 在写操作发生的时钟边沿 写控制信号必须有效  

存取指令 寄存器堆和ALU都会用到  

**符号扩展** 将16位的偏移地址符号扩展成32位的带符号值  
一个保存读出或写入数据的存储单元  
数据存储单元 存储指令时被写入 有读写控制信号  
地址输入 写入存储器的数据输入

**分支指令**
beq 3个操作数 两个是寄存器 比较是否相等   
另一个是16位偏移量 **计算相对分支指令所在地址的分支目标地址**  
为了实现该指令 必须将PC值与符号扩展后的指令偏移量字段相加以得到分支目标地址  
* 指令集规定 计算分支地址使用的**基地址** 是分支指令下一条指令的地址  
* 偏移量左移2位以字为单位的偏移量 这样偏移量的有效范围就扩大了4倍  

**确定是顺序执行or执行分支目标地址处的指令**
* 分支发生 分支条件为真时 分支目标地址称为新的PC
* 分支不发生 分支条件为假时 自增后的PC将取代当前PC 就像普通指令一样  

**分支数据通路**
* 计算分支目标地址 符号扩展单元 加法器
* 比较操作数

ALU提供一个指示结果是否为0的输出信号  可以把两个寄存器数作为输入 并将ALU设置为减法    
若ALU输出的零信号有效 则可知两个操作数相等  

**数据存储单元** 读控制信号  
读一个无效地址可能会出现问题  
写使能信号 用于写操作

**跳转指令**
将偏移地址的第26位左移两位后 以之替代PC的28位  
移位通过给偏移量后面加上两个0来实现  

#### 创建一个简单的数据通路  
不同指令之间共享数据通路单元 让功能单元有多个输入  
使用多选器和控制信号来从多个输入中进行选择  

R型指令和访存指令的数据通路区别

|区别|算术逻辑指令(R型)|访存指令(I型)|
|--|--|--|
|ALU|输入来自两个寄存器|用ALU进行地址计算 第二个输入是对指令中16位偏移地址进行符号扩展后的值|
|存入目标寄存器的值来源|ALU|存储器（取数指令）|

P172 简单的核心MIPS系统结构数据通路
***
## 4.4 一个简单的实现机制
### 4.4.1 ALU控制
MIPS ALU 在4位控制信号上定义了6种有效的输入组合

|ALU控制信号|功能|
|:---:|:---:|
|0000|与|
|0110|减|
|0001|或|
|0111|小于则置位|
|0010|加|
|1100|或非|

R型指令 根据指令低6位的funct字段  
ALU执行5种操作中的一种   
对相等则分支 ALU执行减法操作  

**多级译码**  
主控制单元生成ALUOp作为ALU控制单元的输入  
再由ALU控制单元生成真正控制ALU的信号  
**可以减小主控制单元的规模**  
**提高控制单元的速度**

|指令操作码|ALUOp|指令操作|funct字段|ALU动作|ALU控制信号|
|:---:|:---:|:---:|:---:|:---:|:---:|
|取字|00|取字|XXXXXX|加|0010|
|存字|00|存储字|XXXXXX|加|0010|
|相等则分支|01|相等分支|XXXXXX|减|0110|
|R类型|10|加|100000|加|0010|
|R类型|10|减|100010|减|0110|
|R类型|10|与|100100|与|0000|
|R类型|10|或|100101|或|0001|
|R类型|10|小于则置位|101010|小于则置位|0111|

2位ALUOp和6位funct字段映射成4位ALU控制信号

### 4.4.2 主控制单元的设计

|控制信号名|无效含义|有效含义|
|:----:|:---:|:---:|
|RegDst|写寄存器的目标寄存器号来自rt|写寄存器的目标寄存器号来自rd|
|RegWrite|无|寄存器堆写使能有效|
|ALUSrc|第二个ALU操作数来自寄存器堆的第二个输出|第二个ALU操作数为指令低16位的符号扩展|
|PCSrc|PC由PC+4取代|PC由分支目标地址取代|
|MemRead|无|数据存储器读使能有效|
|MemWrite|无|将写入数据输入段的数据写入到用地址指定存储器单元中取|
|MemtoReg|写入寄存器的数据来自ALU|写入寄存器的数据来自数据存储器|

除了PCSrc控制信号外 所有控制信号都可以由控制单元只根据指令的操作码来确定  

**PCSrc信号有效的条件**
* 指令为相等则分支  
* 用于等值比较的ALU零输出有效

需要将一个来自控制单元称为Branch的信号和ALU零输出信号相与

#### 1.数据通路的操作

#### 2. 控制的结束

**单周期实现**

单时钟周期实现 一个时钟周期执行一条指令的实现机制  
太慢而且不实用  

**跳转的实现**

拼接城的跳转地址
* 当前PC+4的高四位
* 跳转指令的26位立即数字段
* 低位 00<sub>(2)</sub>

只有指令操作码为2时，该控制信号才有效  

### 4.4.3 为什么不使用单周期实现方法

效率太低  
对所有指令等长 是州州旗由执行时间最长的那条指令决定  
**取数指令** 依次使用了五个功能单元：指令存储器 寄存器堆 ALU 数据存储器 寄存器堆

CPI=1 但单周期实现方法的总体性能并不一定很好 时钟周期太长

***
## 补充：多周期

### MIPS指令执行过程划分为五个周期：
1. IF：取指
2. ID：译码和读寄存器
3. EX（BC）：执行/地址计算（分支完成）
4. MEM（WB）：存储器访问（R型指令写回）
5. WB：写回

### 五个周期
#### 取指周期（IF）：
根据PC从存储器中取出一条指令并送到指令寄存器（IR）中，将PC的内容加4并写到PC中。

该周期的操作可使用RTL （Register-Transfer Language）简单描述为：	  
     IR = Memory[PC];  
    PC = PC + 4;  

#### 
