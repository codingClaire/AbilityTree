# 2 **指令：计算机的语言**

## **2.1 引言**

### **指令集**
一个给定的计算机体系结构所包含的指令级和  
两种形式：
* 编程书写的形式
* 计算机能够识别的形式

### **MIPS指令集**

理解如何表述指令--->计算机的秘密 **存储程序概念**
#### **存储程序概念**
多种类型的指令和数据均以**数字形式**存储于存储器中的概念  
存储程序性计算机即源于此
#### **MIPS操作数**

| 名字 |  示例 |注释|
|:-----:|:------:|:------:|
| 32个寄存器| $s0-$s7（C/Java程序中的变量对应的寄存器）</br>$t0-$t9（C程序编译位MIPS指令时需要的临时寄存器）</br>$zero(恒为0)</br>$a0-$a3</br>$v0-$v1</br>$gp</br>$fp</br>$sp</br>$ra</br>$at(被汇编器保留用于处理大的常数)|寄存器用于**数据的快速存取**</br> 只能对寄存器中的数据执行**算术操作**|
|2<sup>30</sup>个存储器字|Memory[0],Memory[1],...</br>Memory[4294967292]|存储器只能通过**数据传输指令**访问</br>MIPS使用**字节**编址 **连续的字地址相差4**</br>存储器用于**保存数据结构、数组和溢出的存储器**|

#### MIPS汇编语言

|类别|指令|示例|含义|注释|
|:-----:|:----:|:--------:|:-----:|:-------:|
|算术|加法| `add $s1,$s2,$s3`|$s1=$s2+$s3|三个寄存器操作数|
|算术|减法|`sub $s1,$s2,$s3`|$s1=$s2+$s3|三个寄存器操作数|
|算术|立即数加法|`addi $s1,$s2,20`|$s1=$s2+20|用于加常数数据|
|数据传输|取字|`lw $s1,20($s2)`|$s1=Memory[$s2+20]|将一个字从内存中取到寄存器中|
|数据传输|存字|`sw $s1,20($s2)`|Memory[$s2+20]=$s1|将一个字从寄存器中取到内存里|
|逻辑|与|`and $s1,$s2,$s3`|$s1=$s2&$s3|三个寄存器操作数按位与|
|逻辑|或|`or $s1,$s2,$s3`|$s1=$s2｜$s3|三个寄存器操作数按位或|
|逻辑|或非|`nor $s1,$s2,$s3`|$s1=~($s2｜$s3)|三个寄存器操作数按位或非|
|逻辑|逻辑左移|`sll $s1,$s2,10`|$s1=$s2<<10|根据常数左移相应位|
|逻辑|逻辑右移|`srl $s1,$s2,10`|$s1=$s2>>10|根据常数右移相应位|
|条件分支|相等时跳转|`beq $s1 $s2,25`|if($s1==$s2) go to PC+4+100|相等检测；和PC相关的跳转|
|条件分支|不相等时跳转|`bne $s1 $s2,25`|if($s1!=$s2) go to PC+4+100|不相等检测；和PC相关的跳转|
|条件分支|小于时则置位|`slt $s1,$s2,$s3`|if($s2<$s3) $s1=1;else $s1=0;|比较是否小于;beq,bne|
|条件分支|无符号数比较小于时置位|`sltu $s1,$s2,$s3`|if($s2<$s3) $s1=1;else $s1=0;|比较是否小于无符号数|
|条件分支|无符号数比较小于立即数时置位|`slti $s1,$s2,20`|if($s2<20) $s1=1;else $s1=0;|比较是否小于常数|
|条件分支|无符号数比较小于无符号立即数时置位|`sltiu $s1,$s2,20`|if($s2<20) $s1=1;else $s1=0;|比较是否小于无符号常数|
|无条件跳转|跳转|`j 2500`|go to 10000|跳转到目标地址|
|无条件跳转|跳转至寄存器所指的位置|jr $ra|go to $ra|用于switch语句以及**过程调用**|
|无条件跳转|跳转并链接|jal 2500|$ra=PC+4;go to 10000|用于过程调用|

***
## **2.2 计算机硬件的操作**

每条MIPS算术指令只执行一个操作 并且有且仅有3个变量

**四个变量的相加**
```
add a,b,c #b和c相加并将得到的和存储在a中
add a,a,d
add a,a,e
```
 #后的是注释 注释总是在一行的末尾结束  
 每行最多只有一条指令

### **硬件设计的基本原则**
#### **设计原则1：简单源于规整**
操作数固定是3个，如果它可变的话，就会使硬件设计带来更大的复杂性

**C语言编译位MIPS**
C语言编译为MIPS指令-->由编译器完成的

```
a=b+c
d=a-e
MIPS指令为
add a,b,c
sub d,a,e
```
```
f=(g+h)-(i+j)
MIPS指令为
为了暂存中间结果，编译器需要创建一个临时的变量t0
add t0,g,h #临时变量存储g和h之和
add t1,i,j
sub f,t0,t1
```
***
## **2.3 计算机硬件的操作数**
MIPS指令的操作数**必须**来自**寄存器**  
寄存器由硬件直接构建并且数量有限  
MIPS指令中**寄存器的大小是32位**  
32位为一组的情况经常出现  
MIPS指令中将其称为**字**  

字： 计算机中的基本访问单位，通常是32位为一组，在MIPS体系结构中与寄存器的大小相同

MIPS算术指令的三个操作数限定为必须**从32个32位寄存器中选取**

#### **设计原则2：越小越快**
寄存器越多，时钟周期会变长，电信号传输更远的距离需要花费更多的时间  
为什么我们要使用32个寄存器？
* 平衡寄存器的数量和时钟周期
* 受到指令格式位数的限制

### **2.3.1 存储器操作数**
数据结构中的数据元素的数量>>计算机中寄存器的个数
如何表示和访问？

MIPS的算术运算指令只对寄存器进行操作的
数据存在存储器里

** 数据传送指令** 在存储器和寄存器之间移动数据的命令

为了访问存储器中的一个字
指令必须给出存储器地址

**地址** 用于在存储器空间中指明某特定数据元素位置的值

存储器相当于一个很大的下标从0开始的一维数组</br>地址就相当于下标
#### **取数指令**
将数据从存储器复制到寄存器

**格式**

常数和第二个存储器的值相加就得到**存储器的地址**

| 操作码| 目标寄存器|访问存储器的常数和寄存器|
|:----:|:-----:|:------:|
|lw|

>A是一个含有100个字的数组  
将寄存器$s1分配给g  
$s2分配给h  
设数组A的起始地址（**基址**）存放在寄存器$s3中  
编译g=h+A[8]  
lw $t0,8($s3)  
add $s1,$s2,$t0

数据传送指令中的常量（例题中为8)称为**偏移量**  
存放基址的寄存器（$s3)称为**基址寄存器**


编译器
* 将变量和寄存器对应起来
* 在存储器中为数据结构分配相应的位置
* 将他们的起始地址放入数据传送指令中

8byte的字节类型  
大多数体系结构按**字节**编址

**一个字的地址必然和它所包括的4个字节中某个地址相匹配**<br>
连续字相差4

存储器

|地址|字节地址| 数据|
|:---:|:-----:|:-----:|
|0|0|1|
|1|4|101|
|2|8|10|
|3|12|100|
|...|...|...|

**对齐限制：**
MIPS按照字节编址  
字的起始地址必须是4的倍数  

两种类型的字节寻址的计算机
* 使用最左边或大端字节的地址作为字地址
* 使用最右边或小端字节的地址作为字地址

MIPS 大端编址（big-endian)  
使用相同的地址去访问一个字和四个字节时“端”才起作用

字节寻址影响到数组下标  
正确的字节地址-->与基址寄存器$s3相加得到的偏移量必须时4*8=32 这样才能正确读到A[8]

与取数指令相对应的指令叫做**存数指令**，它将数据从**寄存器**中复制到**存储器**

*lw/sw指令中的地址是二进制，作为主存的DRAM的容量使用二进制表示，而非十进制*
