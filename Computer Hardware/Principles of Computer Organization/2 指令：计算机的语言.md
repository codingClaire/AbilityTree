# 2 **指令：计算机的语言**

## **2.1 引言**

### **指令集**
一个给定的计算机体系结构所包含的指令级和  
两种形式：
* 编程书写的形式
* 计算机能够识别的形式

### **MIPS指令集**

理解如何表述指令--->计算机的秘密 **存储程序概念**
#### **存储程序概念**
多种类型的指令和数据均以**数字形式**存储于存储器中的概念  
存储程序性计算机即源于此
#### **MIPS操作数**

| 名字 |  示例 |注释|
|:-----:|:------:|:------:|
| 32个寄存器| $s0-$s7（C/Java程序中的变量对应的寄存器）</br>$t0-$t9（C程序编译位MIPS指令时需要的临时寄存器）</br>$zero(恒为0)</br>$a0-$a3(用于传递参数的4个参数寄存器)</br>$v0-$v1(用于返回值的两个值寄存器)</br>$gp</br>$fp</br>$sp(stack pointer 栈指针)</br>$ra(用于返回起始点的返回地址寄存器)</br>$at(被汇编器保留用于处理大的常数)|寄存器用于**数据的快速存取**</br> 只能对寄存器中的数据执行**算术操作**|
|2<sup>30</sup>个存储器字|Memory[0],Memory[1],...</br>Memory[4294967292]|存储器只能通过**数据传输指令**访问</br>MIPS使用**字节**编址 **连续的字地址相差4**</br>存储器用于**保存数据结构、数组和溢出的存储器**|

#### MIPS汇编语言

|类别|指令|示例|含义|注释|
|:-----:|:----:|:--------:|:-----:|:-------:|
|算术|加法| `add $s1,$s2,$s3`|$s1=$s2+$s3|三个寄存器操作数|
|算术|减法|`sub $s1,$s2,$s3`|$s1=$s2+$s3|三个寄存器操作数|
|算术|立即数加法|`addi $s1,$s2,20`|$s1=$s2+20|用于加常数数据|
|数据传输|取字|`lw $s1,20($s2)`|$s1=Memory[$s2+20]|将一个字从内存中取到寄存器中|
|数据传输|存字|`sw $s1,20($s2)`|Memory[$s2+20]=$s1|将一个字从寄存器中取到内存里|
|逻辑|与|`and $s1,$s2,$s3`|$s1=$s2&$s3|三个寄存器操作数按位与|
|逻辑|或|`or $s1,$s2,$s3`|$s1=$s2｜$s3|三个寄存器操作数按位或|
|逻辑|或非|`nor $s1,$s2,$s3`|$s1=~($s2｜$s3)|三个寄存器操作数按位或非|
|逻辑|逻辑左移|`sll $s1,$s2,10`|$s1=$s2<<10|根据常数左移相应位|
|逻辑|逻辑右移|`srl $s1,$s2,10`|$s1=$s2>>10|根据常数右移相应位|
|条件分支|相等时跳转|`beq $s1 $s2,25`|if($s1==$s2) go to PC+4+100|相等检测；和PC相关的跳转|
|条件分支|不相等时跳转|`bne $s1 $s2,25`|if($s1!=$s2) go to PC+4+100|不相等检测；和PC相关的跳转|
|条件分支|小于时则置位|`slt $s1,$s2,$s3`|if($s2<$s3) $s1=1;else $s1=0;|比较是否小于;beq,bne|
|条件分支|无符号数比较小于时置位|`sltu $s1,$s2,$s3`|if($s2<$s3) $s1=1;else $s1=0;|比较是否小于无符号数|
|条件分支|无符号数比较小于立即数时置位|`slti $s1,$s2,20`|if($s2<20) $s1=1;else $s1=0;|比较是否小于常数|
|条件分支|无符号数比较小于无符号立即数时置位|`sltiu $s1,$s2,20`|if($s2<20) $s1=1;else $s1=0;|比较是否小于无符号常数|
|无条件跳转|跳转|`j 2500`|go to 10000|跳转到目标地址|
|无条件跳转|跳转至寄存器所指的位置|jr $ra|go to $ra|用于switch语句以及**过程调用**|
|无条件跳转|跳转并链接|jal 2500|$ra=PC+4;go to 10000|用于过程调用|

***
## **2.2 计算机硬件的操作**

每条MIPS算术指令只执行一个操作 并且有且仅有3个变量

**四个变量的相加**
```
add a,b,c #b和c相加并将得到的和存储在a中
add a,a,d
add a,a,e
```
 #后的是注释 注释总是在一行的末尾结束  
 每行最多只有一条指令

### **硬件设计的基本原则**
#### **设计原则1：简单源于规整**
操作数固定是3个，如果它可变的话，就会使硬件设计带来更大的复杂性

**C语言编译位MIPS**
C语言编译为MIPS指令-->由编译器完成的

```
a=b+c
d=a-e
MIPS指令为
add a,b,c
sub d,a,e
```
```
f=(g+h)-(i+j)
MIPS指令为
为了暂存中间结果，编译器需要创建一个临时的变量t0
add t0,g,h #临时变量存储g和h之和
add t1,i,j
sub f,t0,t1
```
***
## **2.3 计算机硬件的操作数**
MIPS指令的操作数**必须**来自**寄存器**  
寄存器由硬件直接构建并且数量有限  
MIPS指令中**寄存器的大小是32位**  
32位为一组的情况经常出现  
MIPS指令中将其称为**字**  

字： 计算机中的基本访问单位，通常是32位为一组，在MIPS体系结构中与寄存器的大小相同

MIPS算术指令的三个操作数限定为必须**从32个32位寄存器中选取**

#### **设计原则2：越小越快**
寄存器越多，时钟周期会变长，电信号传输更远的距离需要花费更多的时间  
为什么我们要使用32个寄存器？
* 平衡寄存器的数量和时钟周期
* 受到指令格式位数的限制

### **2.3.1 存储器操作数**
数据结构中的数据元素的数量>>计算机中寄存器的个数
如何表示和访问？

MIPS的算术运算指令只对寄存器进行操作的
数据存在存储器里

** 数据传送指令** 在存储器和寄存器之间移动数据的命令

为了访问存储器中的一个字
指令必须给出存储器地址

**地址** 用于在存储器空间中指明某特定数据元素位置的值

存储器相当于一个很大的下标从0开始的一维数组</br>地址就相当于下标
#### **取数指令**
将数据从存储器复制到寄存器

**格式**

常数和第二个存储器的值相加就得到**存储器的地址**

| 操作码| 目标寄存器|访问存储器的常数和寄存器|
|:----:|:-----:|:------:|
|lw|

>A是一个含有100个字的数组  
将寄存器$s1分配给g  
$s2分配给h  
设数组A的起始地址（**基址**）存放在寄存器$s3中  
编译g=h+A[8]  
lw $t0,8($s3)  
add $s1,$s2,$t0

数据传送指令中的常量（例题中为8)称为**偏移量**  
存放基址的寄存器（$s3)称为**基址寄存器**


编译器
* 将变量和寄存器对应起来
* 在存储器中为数据结构分配相应的位置
* 将他们的起始地址放入数据传送指令中

8byte的字节类型  
大多数体系结构按**字节**编址

**一个字的地址必然和它所包括的4个字节中某个地址相匹配**<br>
连续字相差4

存储器

|地址|字节地址| 数据|
|:---:|:-----:|:-----:|
|0|0|1|
|1|4|101|
|2|8|10|
|3|12|100|
|...|...|...|

**对齐限制：**
MIPS按照字节编址  
字的起始地址必须是4的倍数  

两种类型的字节寻址的计算机
* 使用最左边或大端字节的地址作为字地址
* 使用最右边或小端字节的地址作为字地址

MIPS 大端编址（big-endian)  
使用相同的地址去访问一个字和四个字节时“端”才起作用

字节寻址影响到数组下标  
正确的字节地址-->与基址寄存器$s3相加得到的偏移量必须时4*8=32 这样才能正确读到A[8]

与取数指令相对应的指令叫做**存数指令**，它将数据从**寄存器**中复制到**存储器**

*lw/sw指令中的地址是二进制，作为主存的DRAM的容量使用二进制表示，而非十进制*

>设变量h存放在寄存器$s2中，数组A的基址放在$s3中  
编译A[12]=h+A[8]  
lw $t0,32($s3)  
add $t0,$s2,$t0  
sw $t0,48($s3)  

lw/sw 在MIPS体系结构中在存储器和寄存器之间复制字的指令

**变量>>计算机的寄存器**
最常用的变量保持在寄存器，用取数、存数指令在寄存器和存储器之间传送变量  
不常用的变量存回到存储器中的过程叫**寄存器溢出**  
访问存储器的数据要远慢于访问寄存器中的数据  

|寄存器数据|存储器数据|
|-------|---------|
|数量少| 数量多|
|一条算术运算指令能读两个寄存器、运算、协会结果（更容易利用）|数据传送指令只能完成读/写操作数的操作，不能运算|
|访问时间更短、数据访问速度长并易于利用|访问时间长|
|吞吐率高|吞吐率低|
|功耗更小|功耗更高|

### **2.3.2 常数或立即操作数**

使用常数-->将其从存储器中取出

>使寄存器$s3加4
>
>lw $t0,AddrConstant4($s1)  
add $s3,$s3,$t0  
(假设$s1+AddrConstant4是常数4的存储器地址)
>
>避免使用取数指令 加立即数  
addi $s3,$s3,4

数据传输指令 可以看作一个操作数为0的加法  
$zero恒置为0  
**根据使用频率来确定要定义的常数是加速大概率事件的一个好办法**

***
## **2.4 有符号数和无符号数**

所有信息都由**二进制数位**或**位**组成  
推广到任意进制 第i位d的值是`d*Base^i`  
**最高有效位**  MIPS中最右边的一位  
**最低有效位**  MIPS中最左边的一位  

MIPS中的字有32位  可以表示2<sup>32</sup>个不同的32位模式  
很自然的可以使这些组合表示从0-2<sup>32</sup>-1之间的数  
** 溢出**  操作结果不能被最右端的硬件位所表示

**符号和幅值表示法**
缺点：  
增加一个独立的符号位 （正0和负0的出现）  
计算时不能提前知道结果的符号 还需要额外的一步设置符号  

**二进制补码**
二进制补码中的最小负数，没有相应的正数与之对应
所有负数的最高有效位都是1  
只需检测符号位就能区别正负数  
**溢出** 发生在二进制最左边的符号为与采用无穷多为表示该数时左边位的值不同的情况下  
（符号位不正确）  

取数指令：

|有符号数|无符号数|
|----|------|
|取回有符号数后用符号位填充寄存器中的所有剩余位（符号扩展）|简单地用0来填充数据左侧地剩余位|

处理二进制补码数的简单方法  
* 求反： 按位取反加1
* 符号扩展： 将原来的数放入低位 高位用符号位扩展  

**反码** P53  
**偏移表示法** P53

***
## **2.5 计算机中指令的表示**

指令在计算机内部以**若干或高或低的电信号的序列表示的**  
形式上和数的表示相同  
寄存器名字映射成为数字

|寄存器名字|数字|
|-----|----|
|$t0|8|
|$t7|15|
|$s0|16|
|$s7|23|

>add $t0,$s1,$s2

|op(6位)|rs(5位)|rt(5位)|rd(5位)|shamt(5位)|funct(6位)|
|---|----|----|----|---|---|
|0|17|18|8|0|32|

机器指令分为若干**字段**  

**指令格式** 二进制数字段组成的指令表示形式  
MIPS指令占32位 与数据字的位数相等  

**机器语言** 在计算机系统中用于交流的二进制表示形式

**十六进制** P54

### **MIPS字段**

#### **设计原则3：优秀的设计需要适宜的折中方案**

**R型指令**-->用于寄存器

|op(6位)|rs(5位)|rt(5位)|rd(5位)|shamt(5位)|funct(6位)|
|---|----|----|----|---|---|
|指令的基本操作，通常称为操作码|第一个源操作数寄存器|第二个源操作数寄存器|用于存放操作结果的目的寄存器|位移量|功能，一般称为功能码，指明op字段中操作的特定变式|

**I型指令**-->用于立即数

|op(6位)|rs(5位)|rt(5位)|constant or adress(16位)|
|---|----|----|----|
|指令的基本操作，通常称为操作码|第一个源操作数寄存器|第二个源操作数寄存器|地址字段|

16位的地址字段意味着取字指令相对于**基址寄存器地址**偏址+-2<sup>15</sup>或者32768个字节（+-2<sup>13</sup>或者8192个字）范围内的任意数据字

（还有类似的加立即数指令）

lw $t0,32($s3)  

|op(6位)|rs(5位)|rt(5位)|constant or adress(16位)|
|:---:|:----:|:----:|:----:|
|  lw |$s3|$t0|32|

|指令|格式|op|rs|rt|rd|shamt|funct|adress|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|add|R|0|reg|reg|reg|0|32|n.a|
|sub|R|0|reg|reg|reg|0|34|n.a|
|addi|I|8|reg|reg|n.a|n.a|n.a|常数|
|lw|I|35|reg|reg|n.a|n.a|n.a|adress|
|sw|I|43|reg|reg|n.a|n.a|n.a|afress|


>A[300]=h+A[300]  
>
>lw $t0,1200($t1)  
>add $t0,$s,$t0  
sw $t0,1200($t1)  
>
>|op(6位)|rs(5位)|rt(5位)|rd(5位)|shamt(5位)|funct(6位)|
|---|----|----|----|---|---|
填入对应的十进制数 再将十进制数转化为相应位数的二进制即可

**存储程序的概念**
* 指令用数的形式来表示
* 和数据一样程序存储在存储器中，并且可以读写

***
## **2.6 逻辑操作**

### **第一类逻辑操作：移位**
将一个字里面的所有位都像左/右移动 并在空出来的位上填充0  
sll 左移
> sll $t2,$t0,4
>  
>|指令|格式|op|rs|rt|rd|shamt|funct|adress|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|sll|R|0|0|16|10|4|0|0|

**shamt字段** 表示移位量

sll $t2,$s0,4  # reg $t2 = reg $s0 << 4 bits  
逻辑左移i位 相当于乘2i

### **第二类逻辑操作：按位与/或**
**按位与(AND)**  
or $t0,$t1,$t2 # reg $t0= reg $t1 & reg $t2  
将源操作数中某些位置为0的能力  
前提是将另一个操作数中对应位为0  
后一个操作数传统上被称为**掩码(mask)** 可以隐藏某些位  

**按位与(OR)**  
or $t0,$t1,$t2 # reg $t0= reg $t1 | reg $t2  
ori

### **第三类逻辑操作：按位取反(NOT)**

A nor 0 = A not (A or 0)=not (A)  
t1中存放A t3是0  
nor $t0,$t1,$t3 #reg $t0= ~(reg $t1| reg $t3)  
或非 仅当两个操作位均为0是结果才为1  

***

## **2.7 决策指令**

### **条件分支语句**
* **相等则分支** `beq register1,register2,L1`  
* **不相等则分支** `bne register1,register2,L1`

> if (i==j) f=g+h;  
else f=g-h  
f g h i j对应寄存器 s0--s4  
>```
 bne $s3,$s4,Else  
 add $s0,$s1,$s2
 j Exit
 Else: sub $s0,$s1,$s2 #不相等时跳转到Else
 Exit:..
 ```
>

### **2.7.1 循环**

> ```
while(save[i]==k)
    i++;
    ```
i存在$s3,k存在$s5 save基址在$s6中
```
>Loop： sll $t1,$s3,2 #左移2位等于乘4
add $t1,$t1,$s6 #基址加上偏移量
lw $t0,0($t1) #save[i]读入t0临时寄存器中
bne $t0,$t5,Exit # 不相等就退出
addi $s3,$s3,1 #i++
j Loop #没有在bne跳到Exit 就回到Loop
Exit:...
```

* **小于则置位**
`slt $t0,$s3,$s4 #$t0=1 if $s3<$s4`  
立即数版 `slti $t0,$s3,10 #$t0=1 if $s3<10`

没有提供小于则分支   
 sltu sltui  用于处理无符号整数

 将有符号数作为无符号数处理 是一种检验0<=x<y的低开销方法
 **检查数组的下标是否越界**  
 ```
 sltu $t0,$s1,$s2  #$t0=0 if $s1>=length or $s1<0  
 beq $t0,$zero,IndexOutOfBounds #if t0=0 goto Error
 ```

 ### **2.7.2 case/switch语句**

 switch 转换为if-then-else的语句嵌套  

 有效的方法：**转移地址表/转移表** 包含不同指令序列的表  
 jr 寄存器跳转指令 无条件跳转到寄存器指定的地址  

 ## **2.8 计算机硬件对过程的支持**
 过程：根据提供的参数执行一定任务的存储的子程序  

分配寄存器（见表格）
**跳转和链接指令** `jal ProcedureAddress`  
跳转到某个地址的同时 将下一条指令的地址保存在$ra中  
**链接部分** 指向调用点的地址或链接，以允许过程返回到合适的地址  
**存储在寄存器$ra中的链接部分称为返回地址**
指向调用点的链接使过程可以返回到合适的地址  

**寄存器跳转指令**

`jr $ra`

调用者：调用一个过程 并为过程提供必要参数值的程序  
被调用者：根据调用者提供的参数执行一系列存储的指令
将控制权最后返回调用者的过程  

需要寄存器来保存当前运行的指令地址
**指令地址寄存器**  
也就是**程序计数器**(PC)  
包含在程序中正在被执行指令地址的寄存器  

### **2.8.1 使用更多的寄存器**
需要更多的参数寄存器和返回寄存器  
**将寄存器换出到存储器**  
使用的数据结构 **栈**  

**栈指针：** 指示栈中最近分配的地址的值，指示寄存器被换出的位置  
$sp (第29号)  
**压栈：** 向栈中增加元素  
栈增长是按照地址从高到低的顺序进行的  数据压栈时，栈指针值减小  
**出栈：** 出栈时 站长度缩短 栈指针增大  

>
>```
int leaf_example(int g,int h,int i,int j)
{
    int f;
    f=(g+h)-(i+j);
    return f;
}
```
>编译后的汇编代码：
>```
addi $sp,$sp,-12 #申请3个栈空间
sw $t1,8($sp) #保存寄存器t1
sw $t0,4($sp) #保存寄存器t0
sw $s0,0($sp) #保存寄存器s0（#以下过程调用）
add $t0,$a0,$a1 # t0保存g+h的值
add $t1,$a2,$a3 # t1保存i+j的值
sub $s0,$t0,$t1 #s0保存着f的值
add $v0,$s0,$zero #v0是返回值寄存器 将f的值复制到一个返回值寄存器中（#以下 返回前 通过从栈中弹出数据 恢复寄存器的三个旧值）
lw $s0,0($sp)
lw $t0,4($sp)
lw $t1,8($sp)
jr $ra#过程末尾处根据跳转寄存器中的返回地址跳转
```

$t0-$t9 10个临时寄存器 在过程调用中不必被保存  
$s0-$s7 8个保留寄存器 在过程调用中必须被保存  

### **2.8.2 嵌套过程**
叶过程：不调用其他过程的过程

C语言存储方式 动态存储 静态存储
$gp 全局指针，指向静态数据区的保留寄存器
### **2.8.3 在栈中为新数据分配空间**（P69）
过程帧（活动记录）：栈中包含过程所保存的寄存器和局部变量的片段      
$fp 帧指针 指向过程帧的第一个字  
（指向给定过程中，保存的寄存器和局部变量的值


### **2.8.4 在堆中为新数据分配空间**
在内存中 位静态变量和动态数据结构提供空间

** MIPS分配内存的约定**
**栈由内存高端开始并向下增长**

|地址|栈|
|:---:|:---:|
|$sp-->7fff fffc|栈|
||动态数据(会在生命期内增长或缩短)[这一区域向上生长 也称为堆]|
|$gp-->1000 8000|静态数据|
|1000 0000|静态数据(存储常量和其他变量的空间)|
||正文(代码段)|
|pc-->0040 0000|正文|
||保留|
|0|保留|

malloc() 在堆上**分配空间**并返回**指向它的指针**  
free() 释放指针指向的堆空间  
忘记释放内存--->内存泄漏  
JAVA 内存分配和无用单元回收机制-->防止错误发生

|名称|寄存器号|用途|调用时是否保存|
|:---:|:---:|:---:|:---:|
|$zero|0|常数0|不适用|
|$v0-$v1|2-3|计算结果和表达式求值|否|
|$a0-$a3|4-7|参数|否|
|$t0-$t7|8-15|临时变量|否|
|$s0-$s7|16-23|保存的寄存器|是|
|$t8-$t9|24-25|更多的临时变量|否|
|$gp|28|全局指针|是|
|$sp|29|栈指针|是|
|$fp|30|帧指针|是|
|$ra|31|返回地址|是|

***
## **2.10 MIPS中32位立即数**

### **2.10.1 32位立即数**

**读取立即数高位指令** load upper immediate  
`lui $t0,255` 将0000 0000 1111 1111 放置到高16位中  
>加载常量到寄存器$s0  
0000 0000 0011 1101 0000 1001 0000 0000  
```
lui $s0,61 #高16位加载
ori $s0,$s0,2304 #插入低16位
```

*addi将指令最左边的16位立即数数字段复制到一个字的高16位中*

### **2.10.2 分支和跳转中的寻址**

**J型指令类型**

j 10000 # go to location 10000

|j|10000|
|:--:|:---|
|2|10000|
|6位|26位|

条件分支指令
bne $s0,$s1,Exit

|op(6位)|rs(5位)|rt(5位)|constant or adress(16位)|
|:---:|:----:|:----:|:----:|
|bne(5)|$s0(16)|$s1(17)|Exit|

用于指定分支地址 16位

程序地址适应该16位字段--> 任何程序都不能大于2<sup>16</sup>

指定一个总是加到分支地址上的寄存器  
**分支指令的地址计算方式：
程序计数器=寄存器+分支地址**

结果允许程序大小到达2<sup>32</sup> 仍能使用条件分支  

条件分支语句如何使用：  
程序计数器包含当前指令的地址   
**PC相对寻址** 使用PC来作为增加地址的寄存器  
可转移到离当前指令距离位+-2<sup>15</sup>个字的地方  

MIPS寻址实际上是相对于下一条指令的地址(PC+4) 而不是相对于当前指令

使用跳转和跳转链接指令的J型格式来**为过程调用提供长地址**

4字节长的指令 PC相对寻址所加的地址被设计为**字地址**  
跳转指令中26位字段可以表示28位的字节地址  

#### 远距离的分支转移
```
beq $s0,$s1,L1 # 相等时需要跳转

bne $s0,$s1,L2
j L1
L2:
```

### **2.10.3 MIPS寻址模式总结**

#### 5种MIPS寻址模式
##### 立即数寻址
操作数 指令自身的字段 I型指令的低16位
##### 寄存器寻址
R型指令
##### 基址寻址
地址是指令中基址寄存器和常数的和 I型指令
##### PC相对寻址
寻址指令在内存中
I型指令 16位地址左移两位与PC相加

##### 伪直接寻址
J型指令
寻址指令在内存中 26位地址左移2位于PC计数器的高四位连接

### **2.10.4 机器语言解码**

***

## **2.11 并行与指令：同步**
任务之间相互独立的时候， 并行执行  
任务之间需要同步 否则就有发生数据竞争的危险

加锁  
解锁  
互斥区  
原子交换原语  
链接取数  
条件存数  

## **2.12 翻译并执行程序**
```
C语言程序(.c)
  |
  |编译器
  |
汇编语言程序(.s)
  |
  |汇编器
  |
目标模块：机器语言模块(.o)   目标库：例程序（机器语言）(.a)
            |________________|
                    |
                    |链接器
                    |
            可执行代码：机器语言程序(.out)
                    |
                    |加载器
                    |
                  存储器
  ```

### 2.12.1 编译器
能被翻译成二进制的机器语言
### 2.12.2 汇编器
伪指令：汇编语言指令的变种  
`move $t0,$t1` 等价于  `add $t0,$zero,$t1`
blt 小于则分支   
bgt 大于则分支  
bge 大于则置位  
ble 小于则置位  

**代价：保留了一个由汇编器使用的寄存器$at**

汇编器的主要任务汇编成机器代码
将会变程序转换成目标文件  

符号表：一个用于匹配标记名和指令所在内存字的地址的列表
**由标号和地址成对构成**

**UNIX系统中的目标文件**
* 目标文件头
* 代码段
* 静态数据段
* 重定位信息
* 符号表
* 调试信息

### 2.12.3 链接器

单独编译和汇编每个过程  
链接器：系统程序 把各个独立汇编的机器语言程序组合起来并且解决所有未定义的标记，最后生成可执行文件  

工作步骤：
* 将代码和数据模块象征性放入内存
* 决定数据和指令标签的地址
* 修补内部和外部引用

### 2.12.4 加载器
工作步骤：
* 读取可执行文件头 确定代码段 数据段的大小
* 为正文和数据创建一个足够大的地址空间
* 将可执行文件中的指令和数据复制到内存中
* 把主程序的参数复制到栈顶
* 初始化机器寄存器 将栈指针指向第一个空位置
* 跳转到启动例程 将参数复制到参数寄存器 调用程序的main函数 main函数返回时，启动例程通过系统调用exit终止程序

### 2.12.5 动态链接库
动态链接库(DLL):在程序执行过程中才被链接的库例程。

### 2.12.6 启动一个JAVA程序
